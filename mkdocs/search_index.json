{
    "docs": [
        {
            "location": "/", 
            "text": "Getting Started with QGL\n\n\nQuantum Gate Language (QGL) is a domain specific language embedded in python for\nspecifying gate sequences on quantum processors. It is a low-level language in\nthe sense that users write programs at the level of gates on physical qubits.\nWhile the QGL developers pay particular attention to the requirements of\nsuperconducting qubit systems, its structure is generic to any qubit system with\ndipole-coupled qubits in a rotating frame. In such systems, the rotation axis in\nthe X-Y plane is determined by the pulse phase, and Z-axis rotations may be\nachieved through \nframe updates\n.\n\n\nChannels\n\n\nMany early quantum processors require non-uniform control parameters to achieve\nhigh-fidelity gates across all qubits in the device. To deal with this, QGL\nprovides a number of \nchannel\n objects to store the \nindividual\n parameters\nneeded to control or measure the qubits.\n\n\nGates in QGL operate on resources known as \nLogicalChannels\n. For control, these\nchannels are either \nQubits\n or \nEdges\n. The \nQubit\n channels encode properties\nspecific to manipulating individual qubits in quantum processor, while \nEdges\n\nencode the connectivity of the device. Since some 2-qubit gates have a preferred\ndirectionality due to the physical parameters of the device, \nEdges\n correspond\nto a \ndirected\n edge in the qubit connectivity graph. Qubit measurements instead\nact upon a third \nLogicalChannel\n type which is the \nMeasurement\n channel. A\nfinal logical resource type is the \nLogicalMarkerChannel\n which is used to carry\nancillary pulse information for things such as event triggers.\n\n\nAll \nLogicalChannels\n must be mapped to \nPhysicalChannels\n in order for the QGL\ncompiler to produce sequence files for the target hardware. The setup of this\nmapping is \ndescribed later\n.\n\n\nWhile setup of these channels is important for final sequence compilation, QGL\nprograms typically refer only to \nQubit\n channels. Actions on other channel\ntypes may be implied by the operation. For example, to create a \nQubit\n object\nin QGL, one can write:\n\n\nq1 = QubitFactory(\nq1\n)\n\n\n\n\nThe \nQubitFactory\n method returns a \nQubit\n object with the properties defined\nby the name \nq1\n if found in the channel library. If the name is not found, then\nthe users gets a \nQubit\n object with the default properties.\n\n\nGate Primitives\n\n\nThe underlying representation of all QGL operations is a \nPulse\n object.\nHowever, users are not expected to create \nPulses\n directly, but instead\ninteract with various pre-defined one- and two-qubit primitives.\n\n\nSingle-Qubit Operations\n\n\nQGL provides the following single-qubit gates:\n\n\n# generic rotation angle and phase\nUtheta(q, angle, phase)\n\n# generic rotations about a specific axis (phase)\nXtheta(q, angle)\nYtheta(q, angle)\nZtheta(q, angle)\n\n# generic rotations of a specific angle\nU(q, phase)\nU90(q, phase)\n\n# rotations of particular angle and phase\n# X (phase = 0)\nX(q)    # rotates by pi (180 degrees)\nX90(q)  # rotates by +pi/2\nX90m(q) # rotates by -pi/2\n\n# Y (phase = pi/2)\nY(q)\nY90(q)\nY90m(q)\n\n# just frame-updates\nZ(q)\nZ90(q)\nZ90m(q)\n\n# identity (delay or no-op)\nId(q, length) # length parameter is optional\n\n# measurement\nMEAS(q)\n\n\n\n\nDue to the utility of Clifford-group operations in characterizing gate\nperformance, QGL also directly provides a primitive to implement the 24-element\nsingle-qubit Clifford group:\n\n\n# atomic Clifford operation on 1-qubit\nAC(q, n)\n\n\n\n\nThis method is \natomic\n because it implements the full 1-qubit Clifford group\nwith one pulse per element, as opposed to requiring a sequence of the primitives\nalready given above. We known of no canonical way to specify the elements of the\nClifford group; consequently, \nAC\n identifies which Clifford by a numerical\nindex (0-23). See the definition of \nAC\n in \nPulsePrimitives.py\n or the\ndefinition of \nC1\n in \nCliffords.py\n to find our enumeration of the group.\n\n\nTwo-qubit Operations\n\n\nQGL provides only one high-level two-qubit primitives, \nCNOT\n. The implementation\nof CNOT may be chosen by specifying the \ncnot_implementation\n key in QGL\ns\n\nconfig file\n.\n\n\n# high-level primitives\nCNOT(q1, q2)\n\n# mid-level primitives\nCNOT_simple(q1, q2) # a single-pulse gate on Edge(q1, q2)\nCNOT_CR(q1, q2)     # an \nechoed\n cross-resonance CNOT gate on Edge(q1, q2)\nZX90_CR(q1, q2)     # a ZX90 on Edge(q1, q2) implemented with \nechoed\n\n                    # cross-resonance pulses\n\n# lowest-level primitives\nechoCR(q1, q2)  # A \nechoed\n cross-resonance pulse\n\n\n\n\nAdditional Parameters\n\n\nAll QGL pulse primitives accept an arbitrary number of additional keyword\narguments. In particular, any QGL primitive accepts a \nlength\n keyword to modify\nthe length of the resulting operation. These additional parameters are passed to\nthe \nshape function\n when the QGL compiler\nconstructs waveforms from \nPulse\n objects.\n\n\nSequences and Simultaneous Operations\n\n\nPrograms in QGL are specified using python lists. For example,\n\n\nq1 = QubitFactory(\nq1\n)\nseq = [X90(q1), X(q1), Y(q1), X90(q1), MEAS(q1)]\n\n\n\n\nThe elements of the list provide a time-ordered sequence of pulses to execute.\nUsing the python list to describe sequences allows for the use of python\ns\npowerful list comprehension syntax to describe sequence variations. For\ninstance, you can concisely write a scan over a rotation angle or delay in a\nlist comprehension such as:\n\n\nseq = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0, 10e-6, 11)]\n\n\n\n\nQGL\ns compiler assumes that such lists of lists represent a series of related\nexperiments and schedules them to occur sequentially in the AWG output.\n\n\nUsers express simultaneity in QGL using the \n*\n operator. For instance,\n\n\nq1 = QubitFactory(\nq1\n)\nq2 = QubitFactory(\nq2\n)\nseq = [X90(q1)*X90(q2), MEAS(q1)*MEAS(q2)]\n\n\n\n\nwould execute the same sequence on \nQubit\ns \nq1\n and \nq2\n. If the gate durations\ndiffer between \nq1\n and \nq2\n, the QGL compiler injects delays to create aligned\n\nPulseBlock\ns. By default, simultaneous pulses are \nleft-aligned\n, meaning that\nthe leading pulse edges are aligned and padding delays are injected on the\ntrailing edge. However, the user may change this behavior with the \nalign\n\nmethod:\n\n\nseq = [align(X90(q1)*X90(q2)), align(MEAS(q1)*MEAS(q2), mode=\nright\n)]\n\n\n\n\nalign\n takes a \nmode\n argument (\nleft\n, \nright\n, or default \ncenter\n) to\nspecify a particular pulse alignment within a \nPulseBlock\n.\n\n\nComposite Pulses\n\n\nOccasionally one wants to construct a sequence of pulses and treat them as if\nthe entire sequence were a single pulse. For this, QGL allows pulses to be\njoined with the \n+\n operator. This allows, for example, us to define\n\n\ndef hadamard(q):\n    return Y90(q) + X(q)\n\n\n\n\nand then use \nhadmard(q)\n just like any other pulse primitive, even though it is\ncomposed of a sequence of two pulses.\n\n\nPulse Shapes and Waveforms\n\n\nThe QGL compiler constructs waveforms to implement the desired quantum\noperations. To do this, each pulse has a \nshapeFun\n (shape function) that is\ncalled with its \nshapeParams\n. A number of commonly used shapes are defined in\nthe \nPulseShapes\n module including:\n\n\n\n\nconstant\n - i.e. a \nsquare\n pulse with constant amplitude\n\n\ntanh\n - essentially a square pulse with rounded edges\n\n\ngaussian\n - a truncated Gaussian shape\n\n\ndrag\n - the DRAG pulse gives a Gaussian shape with its derivative on the opposite quadrature.\n\n\ngaussOn\n - the first half of a truncated Gaussian shape\n\n\ngaussOff\n - the second half of a truncated Gaussian shape\n\n\n\n\nThe default pulse shape is determined by properties in the \nchannel\nlibrary\n. However, the QGL programmer may\noverride the default shape with a keyword argument. For example, to force the\nuse of square pulse shape we may write:\n\n\nseq = [X(q1, shapeFun=PulseShapes.constant), MEAS(q1)]\n\n\n\n\nOne common use case for specifying a shape function is in the construction of\ncomposite pulses. For instance, you may want a square pulse shape with Gaussian\nedges rather than those given by the \ntanh\n function. To do this you might write:\n\n\nseq = [X(q1, shapeFun=PulseShapes.gaussOn) +\\\n       X(q1, shapeFun=PulseShapes.constant) +\\\n       X(q1, shapeFun=PulseShapes.gaussOff),\n       MEAS(q1)]\n\n\n\n\nShape functions can be an arbitrary piece of python code that returns a NumPy\narray of complex values. Shape functions must accept \nall\n of their arguments\nas keyword arguments. The only arguments that are guaranteed to exist are\n\nsamplingRate\n and \nlength\n. The pulse length is always assumed to be units of\nseconds; it is up to the shape function to use the passed sampling rate to\nconvert from time into number of points/samples. As an example, we could define\na ramp shape with\n\n\ndef ramp(length=0, samplingRate=1e9, **kwargs):\n    numPts = int(np.round(length * samplingRate))\n    return np.linspace(0, 1, numPts)\n\n\n\n\nThen use it with any pulse primitive, e.g.:\n\n\nseq = [X(q1, shapeFun=ramp)]\n\n\n\n\nIf your custom shape function requires additional arguments, you must either\narrange for these parameters to exist in the \nLogicalChannel\ns \nshapeParams\n\ndictionary, or pass them at the call site. For instance,\n\n\ndef foo(length=0, samplingRate=1e9, bar=1, **kwargs):\n    numPts = int(np.round(length * samplingRate))\n    # something involving bar...\n\nseq = [X(q1, bar=0.5, shapeFun=foo)] # bar is passed as a keyword arg\n\n\n\n\nSee the \nPulseShapes\n module for further examples.\n\n\nCompiling and Plotting\n\n\nTo reduce a pulse sequence to AWG vendor-specific hardware instructions, use the\n\ncompile_to_hardware()\n method, e.g.:\n\n\nseq = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0, 10e-6, 11)]\nmeta_info = compile_to_hardware(seq, 'test/ramsey')\n\n\n\n\nThis code snippet will create a folder called \ntest\n inside\n\nAWGDir\n and produce sequence files for each\nAWG targeted by the \nPhysicalChannels\n associated with the QGL program. For\ninstance, if the \nq1\n channel targeted an AWG named \nAPS1\n and the \nM-q1\n\nchannel targeted \nAPS2\n, then the above call to \ncompile_to_hardware\n would\nproduce two files: \nramsey-APS1.h5\n and \nramsey-APS2.h5\n in the \ntest\n folder.\nIt would also produce a \nmeta information\n file \nramsey-meta.json\n which\ncontains data about the QGL program that may be useful for executing the\nprogram in an instrument control platform such as\n\nAuspex\n. \ncompile_to_hardware\n returns the\npath to this meta info file.\n\n\nThe \nplot_pulse_files()\n creates a visual representation of the pulse sequence\ncreated by a QGL program. For example,\n\n\nplot_pulse_files(meta_info)\n\n\n\n\nwill create an interactive plot where each line represents a physical output\nchannel of an AWG referenced by the QGL program.\n\n\nYou may also view a QGL program prior to the logical -\n physical mapping with\n\nshow()\n. For example,\n\n\nseq = [X90(q1), Id(q1, length=100e-9), X90(q1), MEAS(q1)]\nshow(seq)\n\n\n\n\nwill create a plot grid where each subplot shows the operations on individual\n\nLogicalChannels\n.\n\n\nAxis Descriptors\n\n\nTODO", 
            "title": "Intro"
        }, 
        {
            "location": "/#getting-started-with-qgl", 
            "text": "Quantum Gate Language (QGL) is a domain specific language embedded in python for\nspecifying gate sequences on quantum processors. It is a low-level language in\nthe sense that users write programs at the level of gates on physical qubits.\nWhile the QGL developers pay particular attention to the requirements of\nsuperconducting qubit systems, its structure is generic to any qubit system with\ndipole-coupled qubits in a rotating frame. In such systems, the rotation axis in\nthe X-Y plane is determined by the pulse phase, and Z-axis rotations may be\nachieved through  frame updates .", 
            "title": "Getting Started with QGL"
        }, 
        {
            "location": "/#channels", 
            "text": "Many early quantum processors require non-uniform control parameters to achieve\nhigh-fidelity gates across all qubits in the device. To deal with this, QGL\nprovides a number of  channel  objects to store the  individual  parameters\nneeded to control or measure the qubits.  Gates in QGL operate on resources known as  LogicalChannels . For control, these\nchannels are either  Qubits  or  Edges . The  Qubit  channels encode properties\nspecific to manipulating individual qubits in quantum processor, while  Edges \nencode the connectivity of the device. Since some 2-qubit gates have a preferred\ndirectionality due to the physical parameters of the device,  Edges  correspond\nto a  directed  edge in the qubit connectivity graph. Qubit measurements instead\nact upon a third  LogicalChannel  type which is the  Measurement  channel. A\nfinal logical resource type is the  LogicalMarkerChannel  which is used to carry\nancillary pulse information for things such as event triggers.  All  LogicalChannels  must be mapped to  PhysicalChannels  in order for the QGL\ncompiler to produce sequence files for the target hardware. The setup of this\nmapping is  described later .  While setup of these channels is important for final sequence compilation, QGL\nprograms typically refer only to  Qubit  channels. Actions on other channel\ntypes may be implied by the operation. For example, to create a  Qubit  object\nin QGL, one can write:  q1 = QubitFactory( q1 )  The  QubitFactory  method returns a  Qubit  object with the properties defined\nby the name  q1  if found in the channel library. If the name is not found, then\nthe users gets a  Qubit  object with the default properties.", 
            "title": "Channels"
        }, 
        {
            "location": "/#gate-primitives", 
            "text": "The underlying representation of all QGL operations is a  Pulse  object.\nHowever, users are not expected to create  Pulses  directly, but instead\ninteract with various pre-defined one- and two-qubit primitives.", 
            "title": "Gate Primitives"
        }, 
        {
            "location": "/#single-qubit-operations", 
            "text": "QGL provides the following single-qubit gates:  # generic rotation angle and phase\nUtheta(q, angle, phase)\n\n# generic rotations about a specific axis (phase)\nXtheta(q, angle)\nYtheta(q, angle)\nZtheta(q, angle)\n\n# generic rotations of a specific angle\nU(q, phase)\nU90(q, phase)\n\n# rotations of particular angle and phase\n# X (phase = 0)\nX(q)    # rotates by pi (180 degrees)\nX90(q)  # rotates by +pi/2\nX90m(q) # rotates by -pi/2\n\n# Y (phase = pi/2)\nY(q)\nY90(q)\nY90m(q)\n\n# just frame-updates\nZ(q)\nZ90(q)\nZ90m(q)\n\n# identity (delay or no-op)\nId(q, length) # length parameter is optional\n\n# measurement\nMEAS(q)  Due to the utility of Clifford-group operations in characterizing gate\nperformance, QGL also directly provides a primitive to implement the 24-element\nsingle-qubit Clifford group:  # atomic Clifford operation on 1-qubit\nAC(q, n)  This method is  atomic  because it implements the full 1-qubit Clifford group\nwith one pulse per element, as opposed to requiring a sequence of the primitives\nalready given above. We known of no canonical way to specify the elements of the\nClifford group; consequently,  AC  identifies which Clifford by a numerical\nindex (0-23). See the definition of  AC  in  PulsePrimitives.py  or the\ndefinition of  C1  in  Cliffords.py  to find our enumeration of the group.", 
            "title": "Single-Qubit Operations"
        }, 
        {
            "location": "/#two-qubit-operations", 
            "text": "QGL provides only one high-level two-qubit primitives,  CNOT . The implementation\nof CNOT may be chosen by specifying the  cnot_implementation  key in QGL s config file .  # high-level primitives\nCNOT(q1, q2)\n\n# mid-level primitives\nCNOT_simple(q1, q2) # a single-pulse gate on Edge(q1, q2)\nCNOT_CR(q1, q2)     # an  echoed  cross-resonance CNOT gate on Edge(q1, q2)\nZX90_CR(q1, q2)     # a ZX90 on Edge(q1, q2) implemented with  echoed \n                    # cross-resonance pulses\n\n# lowest-level primitives\nechoCR(q1, q2)  # A  echoed  cross-resonance pulse", 
            "title": "Two-qubit Operations"
        }, 
        {
            "location": "/#additional-parameters", 
            "text": "All QGL pulse primitives accept an arbitrary number of additional keyword\narguments. In particular, any QGL primitive accepts a  length  keyword to modify\nthe length of the resulting operation. These additional parameters are passed to\nthe  shape function  when the QGL compiler\nconstructs waveforms from  Pulse  objects.", 
            "title": "Additional Parameters"
        }, 
        {
            "location": "/#sequences-and-simultaneous-operations", 
            "text": "Programs in QGL are specified using python lists. For example,  q1 = QubitFactory( q1 )\nseq = [X90(q1), X(q1), Y(q1), X90(q1), MEAS(q1)]  The elements of the list provide a time-ordered sequence of pulses to execute.\nUsing the python list to describe sequences allows for the use of python s\npowerful list comprehension syntax to describe sequence variations. For\ninstance, you can concisely write a scan over a rotation angle or delay in a\nlist comprehension such as:  seq = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0, 10e-6, 11)]  QGL s compiler assumes that such lists of lists represent a series of related\nexperiments and schedules them to occur sequentially in the AWG output.  Users express simultaneity in QGL using the  *  operator. For instance,  q1 = QubitFactory( q1 )\nq2 = QubitFactory( q2 )\nseq = [X90(q1)*X90(q2), MEAS(q1)*MEAS(q2)]  would execute the same sequence on  Qubit s  q1  and  q2 . If the gate durations\ndiffer between  q1  and  q2 , the QGL compiler injects delays to create aligned PulseBlock s. By default, simultaneous pulses are  left-aligned , meaning that\nthe leading pulse edges are aligned and padding delays are injected on the\ntrailing edge. However, the user may change this behavior with the  align \nmethod:  seq = [align(X90(q1)*X90(q2)), align(MEAS(q1)*MEAS(q2), mode= right )]  align  takes a  mode  argument ( left ,  right , or default  center ) to\nspecify a particular pulse alignment within a  PulseBlock .", 
            "title": "Sequences and Simultaneous Operations"
        }, 
        {
            "location": "/#composite-pulses", 
            "text": "Occasionally one wants to construct a sequence of pulses and treat them as if\nthe entire sequence were a single pulse. For this, QGL allows pulses to be\njoined with the  +  operator. This allows, for example, us to define  def hadamard(q):\n    return Y90(q) + X(q)  and then use  hadmard(q)  just like any other pulse primitive, even though it is\ncomposed of a sequence of two pulses.", 
            "title": "Composite Pulses"
        }, 
        {
            "location": "/#pulse-shapes-and-waveforms", 
            "text": "The QGL compiler constructs waveforms to implement the desired quantum\noperations. To do this, each pulse has a  shapeFun  (shape function) that is\ncalled with its  shapeParams . A number of commonly used shapes are defined in\nthe  PulseShapes  module including:   constant  - i.e. a  square  pulse with constant amplitude  tanh  - essentially a square pulse with rounded edges  gaussian  - a truncated Gaussian shape  drag  - the DRAG pulse gives a Gaussian shape with its derivative on the opposite quadrature.  gaussOn  - the first half of a truncated Gaussian shape  gaussOff  - the second half of a truncated Gaussian shape   The default pulse shape is determined by properties in the  channel\nlibrary . However, the QGL programmer may\noverride the default shape with a keyword argument. For example, to force the\nuse of square pulse shape we may write:  seq = [X(q1, shapeFun=PulseShapes.constant), MEAS(q1)]  One common use case for specifying a shape function is in the construction of\ncomposite pulses. For instance, you may want a square pulse shape with Gaussian\nedges rather than those given by the  tanh  function. To do this you might write:  seq = [X(q1, shapeFun=PulseShapes.gaussOn) +\\\n       X(q1, shapeFun=PulseShapes.constant) +\\\n       X(q1, shapeFun=PulseShapes.gaussOff),\n       MEAS(q1)]  Shape functions can be an arbitrary piece of python code that returns a NumPy\narray of complex values. Shape functions must accept  all  of their arguments\nas keyword arguments. The only arguments that are guaranteed to exist are samplingRate  and  length . The pulse length is always assumed to be units of\nseconds; it is up to the shape function to use the passed sampling rate to\nconvert from time into number of points/samples. As an example, we could define\na ramp shape with  def ramp(length=0, samplingRate=1e9, **kwargs):\n    numPts = int(np.round(length * samplingRate))\n    return np.linspace(0, 1, numPts)  Then use it with any pulse primitive, e.g.:  seq = [X(q1, shapeFun=ramp)]  If your custom shape function requires additional arguments, you must either\narrange for these parameters to exist in the  LogicalChannel s  shapeParams \ndictionary, or pass them at the call site. For instance,  def foo(length=0, samplingRate=1e9, bar=1, **kwargs):\n    numPts = int(np.round(length * samplingRate))\n    # something involving bar...\n\nseq = [X(q1, bar=0.5, shapeFun=foo)] # bar is passed as a keyword arg  See the  PulseShapes  module for further examples.", 
            "title": "Pulse Shapes and Waveforms"
        }, 
        {
            "location": "/#compiling-and-plotting", 
            "text": "To reduce a pulse sequence to AWG vendor-specific hardware instructions, use the compile_to_hardware()  method, e.g.:  seq = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0, 10e-6, 11)]\nmeta_info = compile_to_hardware(seq, 'test/ramsey')  This code snippet will create a folder called  test  inside AWGDir  and produce sequence files for each\nAWG targeted by the  PhysicalChannels  associated with the QGL program. For\ninstance, if the  q1  channel targeted an AWG named  APS1  and the  M-q1 \nchannel targeted  APS2 , then the above call to  compile_to_hardware  would\nproduce two files:  ramsey-APS1.h5  and  ramsey-APS2.h5  in the  test  folder.\nIt would also produce a  meta information  file  ramsey-meta.json  which\ncontains data about the QGL program that may be useful for executing the\nprogram in an instrument control platform such as Auspex .  compile_to_hardware  returns the\npath to this meta info file.  The  plot_pulse_files()  creates a visual representation of the pulse sequence\ncreated by a QGL program. For example,  plot_pulse_files(meta_info)  will create an interactive plot where each line represents a physical output\nchannel of an AWG referenced by the QGL program.  You may also view a QGL program prior to the logical -  physical mapping with show() . For example,  seq = [X90(q1), Id(q1, length=100e-9), X90(q1), MEAS(q1)]\nshow(seq)  will create a plot grid where each subplot shows the operations on individual LogicalChannels .", 
            "title": "Compiling and Plotting"
        }, 
        {
            "location": "/#axis-descriptors", 
            "text": "TODO", 
            "title": "Axis Descriptors"
        }, 
        {
            "location": "/config/", 
            "text": "Channel Library Setup\n\n\nTo produce a sequence file usable with an AWG (e.g. BBN APS1, APS2, or Tek\n5014), QGL relies upon a mapping from \nlogical\n resources (qubits, measurements,\nmarkers) to \nphysical\n resources (specific instrument channels). So, if you\nintend to produce program outputs usable by real hardware, you must first create\na basic channel library with the appropriate logical and physical channels. An\nexample minimal library might include these \nlogical\n channels:\n\n\n\n\nq1 (Qubit)\n\n\nM-q1 (Measurement)\n\n\nslaveTrig (LogicalMarker)\n\n\n\n\nThe naming convention for measurement channels of M-\nqubitname\n \nmust\n be\nfollowed. The \nslaveTrig\n channel is used in master-slave AWG configurations\nwhere one master AWG is used to trigger the start of the slave AWGs.\n\n\nTo create and manage this library, one can use the \nExpSettingsGUI\n from\n\nPyQLab\n. The first tab, labeled \nChannels\n has\ntwo sub-panels for logical and physical channels, respectively. The fastest way\nto get started is to go to the \nInstruments\n tab, select the \nAWG\ns\n sub-tab,\nand create one or more AWGs of the appropriate type. Then, on the \nPhysical\n\nsub-tab of \nChannels\n, click the \nAuto\n button to populate a list of physical\nchannels.  Finally, create a set of logical channels (e.g. \nq1\n of type \nQubit\n,\n\nM-q1\n of type \nMeasurement\n, and \nslaveTrig\n of type \nLogicalMarker\n) and\nselect the appropriate physical channel for each.\n\n\nIf you choose to create physical channels manually, note that these channel\nnames must follow the convention \nAWGName\n-\nchannel\n, where \nAWGName\n\ncorresponds to the name of the corresponding AWG in the instrument library. The\navailable \nchannel\n names depend on the type of AWG.\n\n\nAPS: \n12, 34, 1m1, 2m1, 3m1, 4m1\n\nAPS2: \n12, 12m1, 12m2, 12m3, 12m4\n\nTek5014: \n12, 34, 1m1, 1m2, 2m1, 2m2, 3m1, 3m2, 4m1, 4m2\n\n\nYou\nll notice that QGL explicitly groups pairs of analog output channels into\nquadrature pairs for I/Q modulation of a carrier waveform. Support for\nsingle-channel real output is still a TODO.\n\n\nConfiguration Options\n\n\nQGL depends on a number of global configuration options defined in \nconfig.json\n\nin the QGL package directory. If this file cannot be found when the package is\nloaded, it is created and populated with these default parameters\n\n\n{\n    \nAWGDir\n: \n/my/path/to/awg/\n,\n    \nChannelLibraryFile\n: \n/my/path/to/ChannelParams.json\n,\n    \nPulsePrimitivesLibrary\n: \nstandard\n,\n    \ncnot_implementation\n: \nCNOT_CR\n,\n    \nPlotBackground\n: \n#EAEAF2\n,\n    \nGridColor\n: \nwhite\n\n}\n\n\n\n\nThese parameters control:\n\n\n\n\nAWGDir\n - the directory where sequence file outputs of the compiler should be\n    saved.\n\n\nChannelLibraryFile\n - path to the channel parameters JSON file\n\n\nPulsePrimitivesLibrary\n - \nstandard\n or \nall90\n; the latter uses only 90 rotations\n    to create all operations (e.g. \nX = X90 + X90\n)\n\n\ncnot_implementation\n - names another method to delegate implementation of\n    \nCNOT\n; usually \nCNOT_simple\n or \nCNOT_CR\n\n\nPlotBackground\n - hex string controlling background color of plots\n\n\nGridColor\n - hex string controlling color of grid lines in plots", 
            "title": "Configuration"
        }, 
        {
            "location": "/config/#channel-library-setup", 
            "text": "To produce a sequence file usable with an AWG (e.g. BBN APS1, APS2, or Tek\n5014), QGL relies upon a mapping from  logical  resources (qubits, measurements,\nmarkers) to  physical  resources (specific instrument channels). So, if you\nintend to produce program outputs usable by real hardware, you must first create\na basic channel library with the appropriate logical and physical channels. An\nexample minimal library might include these  logical  channels:   q1 (Qubit)  M-q1 (Measurement)  slaveTrig (LogicalMarker)   The naming convention for measurement channels of M- qubitname   must  be\nfollowed. The  slaveTrig  channel is used in master-slave AWG configurations\nwhere one master AWG is used to trigger the start of the slave AWGs.  To create and manage this library, one can use the  ExpSettingsGUI  from PyQLab . The first tab, labeled  Channels  has\ntwo sub-panels for logical and physical channels, respectively. The fastest way\nto get started is to go to the  Instruments  tab, select the  AWG s  sub-tab,\nand create one or more AWGs of the appropriate type. Then, on the  Physical \nsub-tab of  Channels , click the  Auto  button to populate a list of physical\nchannels.  Finally, create a set of logical channels (e.g.  q1  of type  Qubit , M-q1  of type  Measurement , and  slaveTrig  of type  LogicalMarker ) and\nselect the appropriate physical channel for each.  If you choose to create physical channels manually, note that these channel\nnames must follow the convention  AWGName - channel , where  AWGName \ncorresponds to the name of the corresponding AWG in the instrument library. The\navailable  channel  names depend on the type of AWG.  APS:  12, 34, 1m1, 2m1, 3m1, 4m1 \nAPS2:  12, 12m1, 12m2, 12m3, 12m4 \nTek5014:  12, 34, 1m1, 1m2, 2m1, 2m2, 3m1, 3m2, 4m1, 4m2  You ll notice that QGL explicitly groups pairs of analog output channels into\nquadrature pairs for I/Q modulation of a carrier waveform. Support for\nsingle-channel real output is still a TODO.", 
            "title": "Channel Library Setup"
        }, 
        {
            "location": "/config/#configuration-options", 
            "text": "QGL depends on a number of global configuration options defined in  config.json \nin the QGL package directory. If this file cannot be found when the package is\nloaded, it is created and populated with these default parameters  {\n     AWGDir :  /my/path/to/awg/ ,\n     ChannelLibraryFile :  /my/path/to/ChannelParams.json ,\n     PulsePrimitivesLibrary :  standard ,\n     cnot_implementation :  CNOT_CR ,\n     PlotBackground :  #EAEAF2 ,\n     GridColor :  white \n}  These parameters control:   AWGDir  - the directory where sequence file outputs of the compiler should be\n    saved.  ChannelLibraryFile  - path to the channel parameters JSON file  PulsePrimitivesLibrary  -  standard  or  all90 ; the latter uses only 90 rotations\n    to create all operations (e.g.  X = X90 + X90 )  cnot_implementation  - names another method to delegate implementation of\n     CNOT ; usually  CNOT_simple  or  CNOT_CR  PlotBackground  - hex string controlling background color of plots  GridColor  - hex string controlling color of grid lines in plots", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/examples/", 
            "text": "Ramsey Sequence\n\n\nA simple Ramsey experiment with 51 steps between 0 and 100us:\n\n\nfrom QGL import *\noutput_file() # or output_notebook() from a jupyter notebook\n\nq1 = QubitFactory('q1')\nseqs = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0,100e-6, 51)]\n# get a view of the 10th sequence grouped by logical channels\nshow(seqs[9])\n# compile\ncompile_to_hardware(seqs)\n\n\n\n\nThe \nQubitFactory\n method is a convenience method to create a \nQubit\n object\nwith parameters read from the pulse parameters file. The string \n'q1'\n\nidentifies the qubit label to look up in the parameter file. You can also create\n\nQubit\ns on the fly by passing in parameters to the \nQubit\n constructor.\n\n\nTo define the QGL program, the Ramsey example uses a python list comprehension\nto express a list of sequences in a single line.\n\n\nMulti-qubit Sequence\n\n\nMulti-qubit sequences are represented with notation similar to a tensor product.\nTo get this to work, you must add to your channel library a logical channel\nrepresenting the coupling between qubits. In QGL terminology, this is known as\nan \nEdge\n, and is a \ndirected\n edge in the connectivity graph of your device.\nQGL uses directed edges because certain two-qubit interactions have a preferred\nordering of the interaction. For instance, a cross resonance gate has a\npreferred sign of the qubit-qubit detuning. By storing directed edges, we can\nwrite two-qubit primitives that emit different pulses depending on whether the\n(control, target) pair is aligned or anti-aligned with the underlying\ninteraction Hamiltonian.\n\n\nTo see this in action, add two qubits to your channel library and one edge\n\nq1-q2\n connecting them. Then try the following program:\n\n\nfrom QGL import *\noutput_file() # or output_notebook() from a jupyter notebook\n\nq1 = QubitFactory('q1')\nq2 = QubitFactory('q2')\nseq = [X90(q1)*Y(q2), CNOT(q1,q2), Y(q1), CNOT(q1,q2), X90(q1)*Y(q2), MEAS(q1)*MEAS(q2)]\nshow(seq)\ncompile_to_hardware(seq)\n\n\n\n\nIn this example you can see the use of the two-qubit primitive \nCNOT\n, which by\ndefault emits a sequence of 1- and 2-qubit gates necessary to compose a CNOT\noperation from single-qubit gates and a ZX90, as is appropriate for a\ncross-resonance interaction. The exact sequence will depend on the (source,\ntarget) order you selected in creating the \nq1-q2\n \nEdge\n. You can select a\ndifferent default CNOT implementation by modifying the \ncnot_implementation\n key\nin QGL\ns config.json configuration file.\n\n\nBuilt-in Basic Sequences\n\n\nQGL provides many pre-defined methods for sequences commonly used to\ncharacterize a quantum device. These methods are defined in QGL\ns\n\nBasicSequences\n package and include:\n\n\n\n\nRabiAmp\n\n\nRabiWidth\n\n\nPulsedSpec\n\n\nInversionRecovery\n\n\nRamsey\n\n\nHahnEcho\n\n\nCPMG\n\n\nSingleQubitRB\n\n\nTwoQubitRB\n\n\n\n\nUsage of each is defined in its respective doc string. For instance, at an\nipython prompt, you may type\n\n\nIn [1]: ?RabiAmp\n\n\n\n\nto learn about the \nRabiAmp\n function. We encourage users to peruse the methods\ndefined in \nBasicSequences\n for templates that may be useful in writing their\nown QGL programs.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#ramsey-sequence", 
            "text": "A simple Ramsey experiment with 51 steps between 0 and 100us:  from QGL import *\noutput_file() # or output_notebook() from a jupyter notebook\n\nq1 = QubitFactory('q1')\nseqs = [[X90(q1), Id(q1, length=d), X90(q1), MEAS(q1)] for d in np.linspace(0,100e-6, 51)]\n# get a view of the 10th sequence grouped by logical channels\nshow(seqs[9])\n# compile\ncompile_to_hardware(seqs)  The  QubitFactory  method is a convenience method to create a  Qubit  object\nwith parameters read from the pulse parameters file. The string  'q1' \nidentifies the qubit label to look up in the parameter file. You can also create Qubit s on the fly by passing in parameters to the  Qubit  constructor.  To define the QGL program, the Ramsey example uses a python list comprehension\nto express a list of sequences in a single line.", 
            "title": "Ramsey Sequence"
        }, 
        {
            "location": "/examples/#multi-qubit-sequence", 
            "text": "Multi-qubit sequences are represented with notation similar to a tensor product.\nTo get this to work, you must add to your channel library a logical channel\nrepresenting the coupling between qubits. In QGL terminology, this is known as\nan  Edge , and is a  directed  edge in the connectivity graph of your device.\nQGL uses directed edges because certain two-qubit interactions have a preferred\nordering of the interaction. For instance, a cross resonance gate has a\npreferred sign of the qubit-qubit detuning. By storing directed edges, we can\nwrite two-qubit primitives that emit different pulses depending on whether the\n(control, target) pair is aligned or anti-aligned with the underlying\ninteraction Hamiltonian.  To see this in action, add two qubits to your channel library and one edge q1-q2  connecting them. Then try the following program:  from QGL import *\noutput_file() # or output_notebook() from a jupyter notebook\n\nq1 = QubitFactory('q1')\nq2 = QubitFactory('q2')\nseq = [X90(q1)*Y(q2), CNOT(q1,q2), Y(q1), CNOT(q1,q2), X90(q1)*Y(q2), MEAS(q1)*MEAS(q2)]\nshow(seq)\ncompile_to_hardware(seq)  In this example you can see the use of the two-qubit primitive  CNOT , which by\ndefault emits a sequence of 1- and 2-qubit gates necessary to compose a CNOT\noperation from single-qubit gates and a ZX90, as is appropriate for a\ncross-resonance interaction. The exact sequence will depend on the (source,\ntarget) order you selected in creating the  q1-q2   Edge . You can select a\ndifferent default CNOT implementation by modifying the  cnot_implementation  key\nin QGL s config.json configuration file.", 
            "title": "Multi-qubit Sequence"
        }, 
        {
            "location": "/examples/#built-in-basic-sequences", 
            "text": "QGL provides many pre-defined methods for sequences commonly used to\ncharacterize a quantum device. These methods are defined in QGL s BasicSequences  package and include:   RabiAmp  RabiWidth  PulsedSpec  InversionRecovery  Ramsey  HahnEcho  CPMG  SingleQubitRB  TwoQubitRB   Usage of each is defined in its respective doc string. For instance, at an\nipython prompt, you may type  In [1]: ?RabiAmp  to learn about the  RabiAmp  function. We encourage users to peruse the methods\ndefined in  BasicSequences  for templates that may be useful in writing their\nown QGL programs.", 
            "title": "Built-in Basic Sequences"
        }
    ]
}